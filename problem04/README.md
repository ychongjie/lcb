# 问题4

请设计系统和协议，使⽤以上算法，实现⼿机⽤户的注册和登录，要求能够实现⽤户名与设备的绑定，并应对 10万⽤户/⼩时的注册和登录压⼒，系统应具有横向扩展能⼒

## 分析

1. 10 万用户/小时的压力, 平均 qps 为 28, 粗略认为峰值 qps 为平均 qps 的10 ~ 100 倍, 那么需要设计一个能承受 3000 qps 注册和登录的用户系统.
2. 实现用户名与设备的绑定, 简单认为是用户名与手机号的绑定
3. 需要能水平扩容

## 方案

以下方案以 redis 作为数据库为例. 

拆分成两个服务: 用户中心(UserCenter) 和 ID 生成器(IDGenerator), 用户中心依赖 ID 生成器.

### 1. ID 生成器的设计
将 0 ~ 99999999 这一亿个数分成多个槽位 (分得越细, 后期水平扩容的余地就越大), 例如可以分成 64 个槽位, 分别代表区间 [0, 1562499], [1562500, 3124999] ......
将这些槽位的初始值以 string 的方式存入 redis:
```
set id-bucket:0 0
set id-bucket:1 1562500
...
set id-bucket:63 98437500
```

可以部署多个 IDGenerator 服务(最多64)个, 根据服务数量的不同, 每个服务需要负责不同的槽位.

例如, 如果部署 4 台服务器, 每个服务需要处理 16 个槽位.

对于每一个槽位, IDGenerator 每次将 redis 中对应的值增加 1000, 此后 1000 个对应到该槽位上的用户注册, 无需查询redis, 直接使用内存中递增的值即可.
```
INCRBY id-bucket:0 1000
```

用户注册时, 对其手机号计算 hash, 结果再对 64 求模, 得到它需要使用哪一个 id-bucket 并将其分配到对应的 IDGenerator 上, 由该服务将递增id 转化为随机id.

计算结果有小概率出现碰撞冲突, 此问题由 UserCenter 服务处理.

IDGenerator 使用一致性哈希算法进行水平扩容即可.

### 2. 用户中心的设计

用户相关的 data layout:

* 单个 Hash 存 `手机号-userid` 的键值对, 用来在用户注册时判断该手机号是否已经注册, 例如:
```
HGET phones 13767556733
```

* 一类 Hash 存用户对象, 键为 username (例如 "user-12345678"), 值包含以下字段:
```
phone 手机号
password (加密后的)密码
salt 加密密码的盐值
token 当前用户登录 token
```

* 单个 Hash 存登录 token 对应的用户 id, 用来做用户已登录的校验
```
HGET tokens X2312IDJIEF98923SC
```

注册流程:
1. 判断手机号是否已经注册
2. 如果未注册, 根据手机号的 hash 去对应的 IDGenerator 服务生成新的userid
3. 如果 phones Hash 中查到了对应的 userid, 还需查询用户对象做进一步确认, 判断用户是否真的存在.
4. 如果该 id 对应的 username key 在 redis 上已存在, 重复第二步, 否则将手机号和用户信息存入 redis, 注册成功.

登录流程:
1. 根据手机号查询 userid, 得到 username
2. 根据 username 查询用户信息
3. 校验密码是否匹配, 如果匹配, 则生成新 token 并更新 token 信息, 登录成功

UserCenter 本身是无状态的, 可以水平扩容. 

对应的业务数据, 其中用户信息的 hash 对象可以在 redis-cluster 上做分片, phones 和 tokens 这两个 Hash 则无需分片.






